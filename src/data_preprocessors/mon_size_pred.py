import os
import numpy as np
import pandas as pd
from game import Game


def get_size_concat(db_path) -> pd.DataFrame:
    monster_size_path = os.path.join(db_path, 'monster_size')
    size_concat = []
    for game in list(Game):
        game_name = game.value
        game_size_df = pd.read_csv(os.path.join(monster_size_path, f'{game_name}_size.csv'))
        size_concat.append(game_size_df)
    return pd.concat(size_concat, axis=0)


def get_mon_size_pred_concat(db_path) -> pd.DataFrame:
    def fill_proportional(X: np.ndarray):
        """
        Generated by AI. Given a numpy array, fill the missing values
        using a proportional based algorithm.
        :param X:
        :return:
        """

        X_filled = X.copy()
        n_rows, n_cols = X.shape

        # Step 1: Compute median column ratios from complete rows
        complete_rows = X[~np.isnan(X).any(axis=1)]
        if len(complete_rows) > 0:
            median_ratios = np.median(complete_rows / complete_rows.sum(axis=1, keepdims=True), axis=0)
        else:
            median_ratios = np.ones(n_cols) / n_cols  # Fallback: uniform distribution

        for i in range(n_rows):
            row = X[i]
            known_mask = ~np.isnan(row)
            known_values = row[known_mask]
            missing_mask = np.isnan(row)
            num_missing = missing_mask.sum()

            if num_missing == 0:
                continue  # Skip if no missing values

            # Case 1: Only one known value (use global ratios)
            if len(known_values) == 1:
                known_val = known_values[0]
                X_filled[i, missing_mask] = known_val * median_ratios[missing_mask] / median_ratios[known_mask][0]

            # Case 2: Two known values (preserve their ratio + distribute proportionally)
            elif len(known_values) == 2:
                # Find which columns are known (e.g., col 0 and col 5)
                known_cols = np.where(known_mask)[0]
                col1, col2 = known_cols[0], known_cols[1]
                val1, val2 = row[col1], row[col2]

                # Compute their ratio (e.g., val1 / val2)
                ratio = val1 / val2

                # Fill missing values using global ratios, but adjusted for this row's known ratio
                for j in np.where(missing_mask)[0]:
                    if j < col1:
                        X_filled[i, j] = val1 * (median_ratios[j] / median_ratios[col1])
                    elif col1 < j < col2:
                        X_filled[i, j] = val1 * (median_ratios[j] / median_ratios[col1]) * 0.5 + val2 * (
                                    median_ratios[j] / median_ratios[col2]) * 0.5
                    else:
                        X_filled[i, j] = val2 * (median_ratios[j] / median_ratios[col2])

            # Case 3: 3+ known values (use row-wise proportions)
            else:
                total_known = np.sum(known_values)
                X_filled[i, missing_mask] = total_known / num_missing  # or use fancier logic

        return X_filled

    size_concat = get_size_concat(db_path)
    headers = list(size_concat.columns)
    monsters = list(size_concat['monster'])
    size_concat = size_concat.to_numpy()[:, 1:].astype(float)
    completed = fill_proportional(size_concat)
    result = []
    for i in range(len(monsters)):
        item = {'monster': monsters[i]}
        for j in range(1, len(headers)):  # Exclude monster header
            item[headers[j]] = round(float(completed[i][j-1]), 2)
        result.append(item)
    return pd.DataFrame(result)


def get_mon_size_pred_of_games(db_path):
    monster_size_path = os.path.join(db_path, 'monster_size')
    size_pred_concat = get_mon_size_pred_concat(db_path)
    result = {}
    start_idx = 0
    for game in list(Game):
        game_name = game.value
        curr_sizes_len = len(pd.read_csv(os.path.join(monster_size_path, f'{game_name}_size.csv')))
        result[game] = size_pred_concat[start_idx: start_idx+curr_sizes_len]
        start_idx += curr_sizes_len
    return result
